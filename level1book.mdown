## Level 1 Book

### Challenges
1. In the application:didFinishLaunchingWithOptions: method in the app delegate, use NSLog to output a string to the console, so you can see when this method is called. [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
2. In the application:didFinishLaunchingWithOptions: method in the app delegate, instantiate a UIWindow the size of the bounds of the screen. [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
3. Let’s try showing something to the user.  Create an instance of UIViewController, and make it the UIWindow’s rootViewController. [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
4. Instantiate a new UIView, set it’s background color to [UIColor greenColor], and make it the viewController instance’s view. [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
5. What’s going on, why don’t we see green?  We haven’t yet told the UIWindow that is should be the key window and visible.  Do that now.  (Might not need this) [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
6. It’s called Cocoa Touch for a reason.  Let’s change the alpha of the view whenever a person touches the screen.  To do that, we need to subclass UIViewController.  Update the AppDelegate to use ViewController, our new UIViewController subclass that we are about to create. (change this to just subclass ViewController for the viewDidLoad[b]) [code](https://github.com/envylabs/TryIOSContent/tree/v1b) *Look into using gesture recognizers* *look into using loadView, loadView for creating the objects, viewDidLoad for setting properties on the views, self.loadView*
7. You’ll see we’ve already defined a couple of methods in the ViewController implementation.  These two methods you will always want to override.  Move the UIView creation and setting from the AppDelegate into the viewDidLoad method in the ViewController. [code](https://github.com/envylabs/TryIOSContent/tree/v1a)
8. Now we have the perfect place to write the code that responds to touch events.  Implement the touchesEnded:withEvent: method in the implementation between the curly braces.  In the method definition, use NSLog to log the UIEvent object to the console using %@. [code](https://github.com/envylabs/TryIOSContent/tree/v1c)
9. Uncomment out the code in the touchesEnded:withEvent: that will set a random alpha value on the backgroundColor of our view.  Hit submit and see it in action in the simulator. [code](https://github.com/envylabs/TryIOSContent/tree/v1c)
10. Right now we only have 1 view, so it’s simple enough to do it in code, but Xcode ships with something called Interface Builder, that allows you to graphically layout your interface (aka views).  Interface Builder creates Xib files, which get turned into Nib files, which can be loaded by a UIViewController to construct the views for that controller.  We’ve gone ahead and created a Interface Builder (xib) file that has just 1 UIView in it, much like we had before, and named it ViewController.xib.  Update the instantiation of ViewController with initWithNibName to load in the xib file, and go ahead and remove the manual UIView instantiation in viewDidLoad. [code](https://github.com/envylabs/TryIOSContent/tree/v1d)

## Level 1

In order to write iPhone and iPad applications you're going to need to know a little Objective C.  If you're not comfortable with Objective C please go do one of the following:

* Watch this [CodeTV Screencast](http://www.codeschool.com) on the subject.
* Read through [Learn Objective C](http://cocoadevcentral.com/d/learn_objectivec/)

Go to any bookstore and open up the first iOS development book you see and inevitably, the first
chapter will be all about Xcode.  Xcode is the IDE (Integrated Development Environment) from Apple used
to build iOS and Mac applications.  In this course we're going to encourage you to STAY away from XCode, don't even think about it.  That is because this course, as all other Code School courses, rests on the princicle of Learning by Doing.  And so we've built a completely browser based system for challenging you on what you are learning.  Don't worry though, as we go along we will be sure to point out Xcode resources that you can use to learn the IDE.

#### Video 1

Together in this level we're going to build an application with a Single View that has a background color, and when we tap anywhere on the screen, the alpha transparency of the view will change.  Not terribly complex or interesting, but you have to start somewhere. 

![project files](http://cl.ly/image/0n0z1Z1Y0Y35/Screen%20Shot%202012-09-10%20at%204.05.24%20PM.png)

**The Application Delegate**

When we start a new Xcode project, we usually start out with a bunch of generated files such as `AppDelegate.h` and `AppDelegate.m`, which make up this application's `AppDelegate` class. 

The AppDelegate class defines methods that will be called at different points in the Application Lifecycle (we will cover more about the lifecycle in a future level). Every iPhone application has an AppDelegate, but this one is yours.  One method that you will commonly want to implement is the
`application:didFinishLaunchingWithOptions:` method, that will get called by the OS whenever your application is launched.  But how will we know when it is called?  We can use NSLog inside the method definition, and build and run the application in the iOS simulator and we can see that the string was logged. In case you're not familiar, here is an example of how to use NSLog:

```objc
NSLog(@"Hello World");
```

Notice the @ symbol before the string and the semicolon at the end of the line.  Now go ahead and add this inside the function.

#### Challenge 1

- AppDelegate.h
- AppDelegate.m

In the application:didFinishLaunchingWithOptions: method in the app delegate, use NSLog to output a string (any string you like) to the console, so you can see when this method is called.

```
# AppDelegate.m

#import "AppDelegate.h"

@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSLog(@"Application Did Finish Launching"); 
    return YES;
}
@end

```

-----


Congratulations on running your first iPhone application!  But just logging to the console is not going to get you too high up the App Store best-sellers list.  Let's display someone on the screen for our hypothetical users to interact with.  To do that, we are going to need three things: A Window, a View Controller, and a View.

### The Window

First steps first, we need to figure out how big our iPhone screen is.  To do this we can tell the UIScreen class to send us the mainScreen for our app, and then send the bounds message into the UIScreen instance we received to get back a CGRect instance, like so:

```objc
CGRect viewRect = [[UIScreen mainScreen] bounds];
```

Apple maintains great developer documentation on these common classes, so if you ever want to learn about the properties on such an object just head over there and search for UIScreen or CGRect to learn about these classes and how they can be used.  All these methods are linked below the video.

[UIScreen Class Reference](http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScreen_Class/Reference/UIScreen.html)
[UIWindow Class Reference](http://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIWindow_Class/UIWindowClassReference/UIWindowClassReference.html)

Now `viewRect` is a CGRect object that defines the "bounds" of the screen.  We can verify this works properly by changing our Log to do something like:

```objc
CGRect viewRect = [[UIScreen mainScreen] bounds];
```

When we run this code, you can see that it prints: 

2012-09-24 18:36:30.269 AlphaTouch[19157:c07] Screen is 480.000000 tall and 320.000000 wide

Now that we have the bounds, we can start drawing on it right?  Well not quite, just like a painter needs a canvas to start drawing on we need a canvas or "Window" in our case.

In iOS, the `UIWindow` objects provide an area of an application to display it's views. iPhone applications only have 1 main UIWindow, and usually you will only create the UIWindow object once in the `application:didFinishLaunchingWithOptions:` method and then forget about it. Lets do this now and pass in our CGRect so it knows how big of a window to draw.
 
```
@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
	CGRect viewRect = [[UIScreen mainScreen] bounds];
	UIWindow *window = [[UIWindow alloc] initWithFrame:viewRect];
	
	NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
@end
```

Here we are creating a new UIWindow instance called window.  To do this we are "alloc"ating memory for a new UIWindow, then calling initWithFrame on this new object, sending it the viewRect we created.

There is a problem here, though. When the `application:didFinishLaunchingWithOptions:` method is executed and returns, that `window` variable will go away, and we won't be able to get to it again, and so bad things could happen.  There is an easy fix.  Our AppDelegate header file was generated with a `UIWindow` property named `window`.  If we open it up we can see it right here:

```objc
@property (strong, nonatomic) UIWindow *window;
```

So let's use property syntax to assign the UIWindow to this property `self.window`, like so:

```
@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    
    NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
@end
```

TODO: Not a fan of this challenge, come back.

#### Challenge 2

- AppDelegate.h
- AppDelegate.m

In the application:didFinishLaunchingWithOptions: method in the app delegate, instantiate a UIWindow the size of the bounds of the screen

```
# AppDelegate.m

@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    
    NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
@end
```

----

##### Challenge 3

- AppDelegate.h
- AppDelegate.m

Next up is we have to tell the UIWindow that it's the key window (the window that should receive keyboard and other non-touch related events), and that it should be visible to the user.  We do this by sending `makeKeyAndVisible` to the self.window instance the line after we set the self.window.  Go ahead and try this below.

```
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    [self.window makeKeyAndVisible];
    
    NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
```

But still: the user sees nothing but a black screen (although it [could be worse](http://www.maximumpc.com/files/u69/BSOD_Main.png)) and we get a log message telling us "Application windows are expected to have a root view controller at the end of application launch".  

### View Controllers

If the `window` is the canvas, than you can think of a View Controller as the paintbrush (and the View would be the paint, which we'll get to in a bit).  We need some object that controls what is put on the screen, and that object is a `UIViewController` instance.  It does exactly what it says: it controls views.  A "View" is an actual thing the user can see (like a button), and the View Controller is there to take that Button (`view`) and put it in the canvas (`window`).  

#### Challenge 4

- AppDelegate.h
- AppDelegate.m

Since `window.rootViewController` expects an instance of UIViewController, let's alloc/init
one and assign it:

```objc
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    UIViewController *viewController = [[UIViewController alloc] init];
    self.window.rootReviewController = viewController;
    [self.window makeKeyAndVisible];
    
    NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
```

Great, no more log message that we're missing a root view controller this time.  But wait, now what?  We keep doing these things, and yet the user sits there, bored.  Don't worry, we are very close.  

### Views

We just created the canvas (UIWindow), grabbed our favorite paintbrush (ViewController), and finally it's time to put some paint (View) on the canvas that is our app. Eventually, your app will have many view objects (everything you see in an iPhone app is a view, even from the smallest text label).  Each view represents something on the screen.  It is, quite literally, the paint.  

#### Challenge 5

- AppDelegate.h
- AppDelegate.m

Since we already have created our `rootViewController` instance, we can create an instance of `UIView` and set the `rootViewController.view` property, like so:

```
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    UIViewController *viewController = [[UIViewController alloc] init];
    UIView *view = [[UIView alloc] initWithFrame:viewRect];
    viewController.view = view;
    self.window.rootReviewController = viewController;

    
    [self.window makeKeyAndVisible];
    
    NSLog(@"Screen is %f tall and %f wide", viewRect.size.height, viewRect.size.width);
    return YES;
}
```

As you can see, when we created our view with `initWithFrame`, we passed in the same
`bounds` object that we did when we initialized our `UIWindow` object.  This means that our new view instance will take up the entire window.  We could have passed in a different `bounds` object, with smaller dimensions, and made the view instance take up a subset of space in the window. 

TODO: Thinking about doing this.. smaller box as a challenge.

Before we hit the `Build and Run` button, let's give our new View a background color so
when we run our app, we'll finally see something other than a black void:

```
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];
    UIViewController *viewController = [[UIViewController alloc] init];
    UIView *view = [[UIView alloc] initWithFrame:viewRect];
    
    view.backgroundColor = [UIColor purpleColor];
    viewController.view = view;
    self.window.rootReviewController = viewController;

    
    [self.window makeKeyAndVisible];
    
    NSLog(@"Application Did Finish Launching");
    return YES;
}
```

TODO: Consider making changing the UIColor a challenge.  Look up another color in documentation.

And after hitting 'Build and Run', we get this beauty:

![Our first View](http://f.cl.ly/items/3S270E2T2z0F1S403e0O/Resized%20Screen%202012-09-10%20at%2010.06.11%20PM.png)


### Touch

#### Video 2

It's called Cocoa **Touch** for a reason.  Allowing for a user to *touch* the screen, and make something happen based on that touch, is the bedrock of every app.  This is where our painting analogy falls flat on its face.  A painting, once done, doesn't ever have to worry about the outside world again (there are [exceptions](http://a0.twimg.com/profile_images/2534918647/zj1kewotf1vgvwq8ya11.jpeg), of course).  But your app will have to worry about outside *events*, like touches, or the phone rotating, or a location signal, or a phone call, or a thousand other events.

For now, let's just talk about *touch* events (others will be covered later in the course).  In iOS, Apple created a class called `UIResponder` for *responding* to user events, like touch and motion.  How do you use this class?  Should we just create a `UIResponder` object, and then call some methods on it, something like this:

```
UIResponder *responder = [[UIResponder alloc] init];
[responder respondToTouches];
```

But what would that code actually **do**?  We can't just tell the responder to respond to touches.  No, we want to run some code to **do something** when there is a touch.  For example, let's say we want to change the alpha transparency of the backgroundColor of our `View` whenever the user touches the screen.  So the question arises (as it often does in programming), *where do I put this code?*

The answer to *where do I put this code?* in iOS programming is, very often, **in a subclass**.  We create a own application specific *subclass* and implement methods defined in the parent class (or *superclass*).

Luckily, `UIViewController` is already a subclass of `UIResponder`, so we can just create a *subclass* of `UIViewController` in our app, and implement a method defined in `UIResponder` to respond to a user touch event.  In fact, when Xcode first generated our app earlier in the level, it went ahead and created a subclass of `UIViewController` for you, in `ViewController.h` and `ViewController.m`.  In `ViewController.h`, you can see that our newly created `ViewController` class is a *subclass* of `UIViewController`:

```
#import <UIKit/UIKit.h>

@interface ViewController : UIViewController

@end
```

So now in our implementation file, `ViewController.m`, we can override the 
`touchesEnded:withEvent:` method to do something when a touch happens:

```
@implementation ViewController

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSLog(@"touchesEnded");
}
@end
```

This method is defined in `UIResponder`.  To find other methods defined in `UIResponder`, take a look at the [Class Reference](http://developer.apple.com/library/ios/#documentation/uikit/reference/UIResponder_Class/Reference/Reference.html).  In the following diagram, you'll see how `UIViewController` isn't the only subclass of `UIResponder`:

![UIResponder Hierarchy](http://f.cl.ly/items/1v0K0S443D0X3506073p/UIKit-high-level.png)

- **Note** Above, we handled touch events in the controller, but UIViews are also subclasses of `UIResponder`.  Most of the time, you'll want to define touch handling methods in View subclasses, but because we already had a `UIViewController` subclass created for us by Xcode, it was easier just to do it here.

Before we can see the `@"touchesEnded"` string in the console, we'll need to switch out our use of `UIViewController` for `ViewController` in our `AppDelegate`, like so: (it's a small change).

```
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    
    CGRect viewRect = [[UIScreen mainScreen] bounds];
    self.window = [[UIWindow alloc] initWithFrame:viewRect];

    ViewController *viewController = [[ViewController alloc] init];

    UIView *view = [[UIView alloc] initWithFrame:viewRect];
    view.backgroundColor = [UIColor darkGrayColor];
    viewController.view = view;
    self.window.rootReviewController = viewController;
    [self.window makeKeyAndVisible];
    
    NSLog(@"Application Did Finish Launching");
    return YES;
}
```

Now when we run this code when we click we get the appropriate log message.  Sweet!

This question, *where does this code go?*, is a very important one in iOS development.  Half of learning how to build apps is answering this question.  A derivative of this question is: *is this the correct place for this code to go?*  For example, in the `AppDelegate` method above, we are initializing a `UIView` and setting it as the `view` property on the `ViewController` instance.  Is this the correct place to do that?  

To answer that question, you must ask yourself another question: *what if I wanted to create another `ViewController` instance somewhere else?*  Currently, the answer to this last question would involve duplicating the `UIView` creation and setting.  Duplicated code is a "code smell".  It means something stinks, and we need to do some cleanup.

#### Challenge 6

What we really want is that every time an instance of `ViewController` is created, an instance of `UIView` is created and set as the `view` property.  We can do this by overriding the `loadView` method in our `ViewController` class, like so:

- AppDelegate.h
- AppDelegate.m
- ViewController.m
- ViewController.h

```
@implementation ViewController

- (void)loadView
{
    self.view = [[UIView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.view.backgroundColor = [UIColor darkGrayColor];
}

@end
```

TODO: No idea how this is a challenge

#### Challenge 7

- AppDelegate.h
- AppDelegate.m
- ViewController.m
- ViewController.h

The `loadView` method is called when this View Controller's `view` property is first accessed, which is taken care of by the Cocoa Touch framework your app is written on.  It's usually good practice, when creating Views in code (there are other ways to create views, which we'll get to in a bit), to do so in a `loadView` method on a subclass of `UIViewController`.  It's also good practice to move the View customization code into a method called `viewDidLoad`, like so:

```
@implementation ViewController

- (void)loadView
{
    self.view = [[UIView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    
}

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor darkGrayColor];
}

@end
```

- **Note** You must include `[super viewDidLoad]` to make sure the `UIViewController` class's `viewDidLoad` method is also called. Just make sure you don't call `[super loadView]` in the `loadView` method definition.

#### Challenge 8

- AppDelegate.h
- AppDelegate.m
- ViewController.m
- ViewController.h

Now let's finish up by filling in some code in the `touchesEnded:withEvent:` method definition that will set the alpha transparency of the view to a random value between `0.0` and `1.0`.  We'll leave it as an exercise for the reader to figure out how this works:

```
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    self.view.alpha = ((double)arc4random() / 0x100000000);
}
```

Hopefully, you are starting to get a real feel how iPhone apps are built.  There is the
window with it's root View Controller, and a subclassed View Controller with it's root View.  The View Controller can handle events from the user and update it's View to react to those events.  Subclassing is an easy way to change the behavior for your app.  There is usually a right and wrong place to put certain code, and putting code in the right place is half the battle of building an iOS app.

But almost no app consists of just one simple view, most have hundreds or thousands.  And creating all those views in code can be clunky, and not the right thing to do.  Luckily, Xcode includes a handy tool to graphicly create and layout views, called Interface Builder.

## Interface Builder

#### Video 3

Interface Builder is an incredibly powerful tool for creating the User Interface of your app, and it is highly recommended by Apple that you use Interface Builder instead of creating the interface by writing code.

Interface Builder creates "xib" files.  But we won't really need to worry about what is in those files.  You may have noticed when we generated our AlphaTouch project, Xcode created a "ViewController.xib" file.  If you click on it, you will see this:

![ViewController.xib](http://f.cl.ly/items/3u152q1R2U021z2C2S0E/Resized%20Screen%202012-09-11%20at%202.00.44%20PM.png)

TODO: I didn't see the "Objects" section.  

As you can see in the "Objects" section, there is already one View in this xib.  This View is just an instance of UIView, exactly like the one we created in our `ViewController` `loadView` method earlier.  We can replace our manual View creation code by telling our `ViewController` instance to be created with this Interface Builder file as it's View.  We can do that during initialization, back in our `AppDelegate`, like so:


#### Challenge 9

- AppDelegate.h
- AppDelegate.m
- ViewController.m
- ViewController.h

```
@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    self.viewController = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil];
    self.window.rootViewController = self.viewController;
    [self.window makeKeyAndVisible];
    return YES;
}
@end
```

Instead of just calling `init`, we called `initWithNibName:bundle:` and passed in the name of the "xib".

- **Note** A nib and xib file are basically the same thing: both are products of the Interface Builder tool.  The only difference is that nib files are more compact, machine readable versions of xib files.

#### Challenge 10

- AppDelegate.h
- AppDelegate.m
- ViewController.m
- ViewController.h

Since we are no longer creating views in code, we can completely remove the `loadView` method from `ViewController`, making it look like this:

```
@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor darkGrayColor];
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    self.view.alpha = ((double)arc4random() / 0x100000000);
}

@end

```

You might be wondering how our `ViewController` instance's `view` property was set.  Well, View Controllers that are initialized with Interface Builder files know how to hook up the root view in the Interface Builder file to it's own `view` property.  You don't have to do any of that yourself, you just need to know that you can still use `self.view` to get at the root view of the View Controller.

Build and Run your app and see it all still work.  

You've now learned that you don't always have to create your User Interface in code, and how to tell a View Controller to load it's `view` from an Interface Builder file.  In the next Level, we are going to work more with Interface Builder, and introduce View Hierarchies.

[learnobjc]: http://cocoadevcentral.com/d/learn_objectivec/ "Learn Objective-C"
